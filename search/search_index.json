{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Sanp's blog \u00b6 What is this? \u00b6 This is a blog where I write about random techy / programming things I'm doing. Learn more about me in my About section. Posts \u00b6 Check out the latest posts by going to the side panel nav bar and seeing what's in this year's folder. Blog stack \u00b6 To make this blog, I'm using: mkdocs , a static site framework The material for mkdocs theme Several material for mkdocs extensions The mkdocs-macros plugin Github pages to host At some point, maybe I'll do posts on each of these. For now, you can find more info at their respective websites.","title":"Home"},{"location":"#welcome-to-sanps-blog","text":"","title":"Welcome to Sanp's blog"},{"location":"#what-is-this","text":"This is a blog where I write about random techy / programming things I'm doing. Learn more about me in my About section.","title":"What is this?"},{"location":"#posts","text":"Check out the latest posts by going to the side panel nav bar and seeing what's in this year's folder.","title":"Posts"},{"location":"#blog-stack","text":"To make this blog, I'm using: mkdocs , a static site framework The material for mkdocs theme Several material for mkdocs extensions The mkdocs-macros plugin Github pages to host At some point, maybe I'll do posts on each of these. For now, you can find more info at their respective websites.","title":"Blog stack"},{"location":"about/","text":"About Me \u00b6 Hi, I'm Steve ( @sanp ) \u00b6 I'm a Software Engineer in Chicago and I'm interested in python , vim / neovim , scala , SQL , spark , AWS, and big data. I'm also interested in learning more about functional programming, and I do some basic web development. Links \u00b6 Link to my github . Link to my dotfiles .","title":"About"},{"location":"about/#about-me","text":"","title":"About Me"},{"location":"about/#hi-im-steve-sanp","text":"I'm a Software Engineer in Chicago and I'm interested in python , vim / neovim , scala , SQL , spark , AWS, and big data. I'm also interested in learning more about functional programming, and I do some basic web development.","title":"Hi, I'm Steve (@sanp)"},{"location":"about/#links","text":"Link to my github . Link to my dotfiles .","title":"Links"},{"location":"2019/gitflow/","text":"Using GitFlow to improve your git workflow \u00b6 Intro \u00b6 GitFlow is a basic git workflow created by Vincent Driessen and described in his blog post here . I've been using a modified version of GitFlow for a while now, and thought it would be a good thing to talk about here. In this post, I'm going to describe GitFlow and talk about a couple additional things I do when using it. Disclaimer GitFlow isn't for everyone. It works best when your deployment cycle is based around releases. If your team deploys to production every day or several times a day, GitFlow may be impractical. In this case, github flow might be a better, more lightweight alternative. Basic GitFlow \u00b6 Fig. 1: Image taken from here . Development lifecycle \u00b6 The basic GitFlow is outlined in Fig. 1. GitFlow assumes that your deployment lifecycle is like the following: Work is divided into sprints During a sprint, developers will work on a handful of features When all of the sprint's features are finished, they will be packaged into a release That release is then deployed to production GitFlow helps to accomplish this by having designated branches that correspond to the different stages of this lifecycle. Branches \u00b6 Each repo should have two persistent branches which live forever: develop and master . master contains the code for the release which is currently deployed to production. It should never contain anything which is not released. Anything in master, at any given time, is working production code, and every commit to master is a new release. develop contains code for the next release. During a sprint, new features are added to develop until the sprint ends. In addition to develop and master , there are several short-lived branches which are created for a purpose and then deleted once that purpose is served: Feature branches are used to work on a new feature. They are forked off of develop and then merged back into develop and deleted when complete. Release branches contain all the new features which will be deployed to production in a release. A release branch is basically a bunch of features which will be merged into master at the same time. When a sprint ends, a release branch is forked from develop and then merged back into master and develop . A hotfix is a small change that needs to be made immediately and requires minimal or no testing. A hotfix branch is forked from master and then merged back into develop and master . Working with gitflow: step by step code walkthrough \u00b6 I will now describe what commands you can use to follow GitFlow with your own projects. Starting a project \u00b6 Creating a new repo \u00b6 If you're starting a new project from scratch, you can create a repo for your project and then clone it to your local. Then create the develop branch off of master , and push it to the remote: 1 2 3 4 git clone <repo address> /path/on/local cd /path/on/local git checkout -b develop git push -u origin head Working with an existing repo \u00b6 If a repo for your project already exists, clone the repo to your local: 1 git clone <repo address> /path/on/local Working on a new feature \u00b6 Each feature should correspond to a single ticket in Jira , or whatever software you use to track tickets. All code changes for that ticket should be contained in a single feature branch with the naming convention: feature/<board_name>-<ticket_nunmber>_<ticket_description> 1 . Let's say your team uses a Jira board named ABC In that case, an example feature branch name would be: feature/ABC-2701_cool_new_feature . All Jira tickets should have their own feature branch so that feature branches contain just the minimum code changes needed to close out their corresponding ticket. The following is a step-by-step guide to working on a new feature. One developer working on a feature \u00b6 Step 1: Create a feature branch \u00b6 Let's say you're the only developer working on the feature ABC-2701_cool_new_feature . Create a feature branch from develop and then push the branch: 1 2 3 4 5 6 git checkout develop # Make sure you have the latest changes to develop git pull git checkout -b feature/ABC-2701_cool_new_feature # Set -u (upstream) so that git remembers what remote to push to on this branch git push -u origin head Step 2: Work on the feature and push to remote \u00b6 Once all work is done on the feature, commit your changes and push to the remote repository. Note Before pushing, it's a good idea to make sure you have a clean commit history. Follow the instructions in my blog post on interactive rebasing to ensure that your commit history is clean before merging. 1 2 3 4 5 6 7 8 # Make sure you're on the feature branch git checkout feature/ABC-2701_cool_new_feature # Pull in latest changes git pull # Ensure your changes are compatible with current develop before pushing git merge develop # No need to specify origin head if you did -u earlier git push Note You may need to resolve some merge conflicts at this stage. I recommend DiffMerge for this. Step 3: PR from feature branch into develop \u00b6 To merge the feature branch, open a pull request (PR) 2 into develop . Once the PR is approved, merge it and then delete the feature branch on the remote. Step 4: Clean up local branches \u00b6 Finally, clean up your local branches: 1 2 3 4 5 git checkout develop git pull git br -d feature/ABC-2701_cool_new_feature # Prune the inactive remote branches git fetch -p The feature is now complete. Multiple developers working on a feature \u00b6 If more than one developer is working on the same feature, the process is only slightly more complicated than if one developer is working on the feature. Let's say Alice, Bob, and Carol are all working on the feature from above. The following is how they would each work together. Step 1: Create a feature branch \u00b6 Same as in the one developer scenario, make a feature branch from develop . 1 2 3 4 git checkout develop git pull git checkout -b feature/ABC-2701_cool_new_feature git push -u origin head Step 2: Each developer creates an individual branch \u00b6 Rather than all work on the main feature branch, Alice, Bob, and Carol should all create their own individual branches to work on from the main feature branch. This way, all of their changes are separated. On Alice's local: 1 2 3 4 git checkout feature/ABC-2701_cool_new_feature git pull git checkout -b alice/ABC-2701_cool_new_feature git push -u origin head On Bob's local: 1 2 3 4 git checkout feature/ABC-2701_cool_new_feature git pull git checkout -b bob/ABC-2701_cool_new_feature git push -u origin head On Carol's local: 1 2 3 4 git checkout feature/ABC-2701_cool_new_feature git pull git checkout -b carol/ABC-2701_cool_new_feature git push -u origin head Step 3: Individual work and push to remote \u00b6 Each developer can work on their individual branch. Once a developer is done with their share of the work, they should merge their individual branch into the main feature branch with a PR, while making sure all merge conflicts are resolved. So, if Alice finishes her portion of the ticket, she would do: 1 2 3 4 5 6 7 8 9 # Make sure she's on her individual branch git checkout alice/ABC-2701_cool_new_feature # Pull in latest changes git pull # Merge in the latest changes from the other developers and from develop git merge bob/ABC-2701_cool_new_feature git merge carol/ABC-2701_cool_new_feature git merge develop git push As in the earlier case, make sure all merge conflicts are resolved before pushing. Note Just as in the one developer case, at this stage it is a good idea to rebase your commit history before pushing to the remeote. Follow the instructions here to do that. Step 4: PR from individual branch into main feature branch \u00b6 Once all conflicts are done and merges complete, Alice should create a PR for her feature branch into the main feature branch. Once the PR is approved, merge it, and then delete the individual branch on the remote. Step 5: Repeat for other developers \u00b6 Bob and Carol should repeat steps 3 and 4 for their individual branches. Step 6: PR from feature branch into develop \u00b6 When all individual branches are merged into the main feature branch, the next step is to merge the feature branch into develop. First, ensure that any updates to develop are pulled into the feature branch: 1 2 3 4 git checkout feature/ABC-2701_cool_new_feature git pull git merge develop git push Then create a PR from feature/ABC-2701_cool_new_feature into develop . When that is approved, merge the PR and then delete the feature branch from the remote repo. Step 7: Clean up local branches \u00b6 Finally, clean up your local branches: 1 2 3 4 5 git checkout develop git pull git br -d feature/ABC-2701_cool_new_feature # Prune the inactive remote branches git fetch -p The feature is now complete. Cutting a release branch \u00b6 When you are finished working on all of the features for a release, cut a new release branch off of develop , then merge it into master and develop . Branches are named according to semantic versioning : MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, and PATCH version when you make backwards compatible bug fixes. 1 2 3 4 git checkout develop git pull git checkout -b release/1.0.0 git push -u origin head Then merge the branch into master with a PR, and delete the release branch in the remote and locally: 1 2 3 4 git checkout develop git pull git br -d release/1.0.0 git fetch -p You have now released a new release. Appendix \u00b6 One developer optional variation: using an individual branch \u00b6 In the above section on GitFlow for one developer , it calls for that developer to create a feature branch, work on it, and then eventually merge that feature branch back into develop with a PR. Ideally, before a branch is merged, its commit history should be clean by following the steps in my interactive rebasing post . However, because rebasing involves rewriting history, it's best not to rebase commits on branches that have already been pushed to a remote repository. This leaves two options. The first option is to do all work on your feature branch locally and only push to the remote once work on the branch is complete and the commit log has been rebased locally. This is okay for features that do not take a long time to complete; however, for features that take many days to complete, it is not ideal. A better approach is to create an individual branch, forked off of the feature branch, and work on that branch until development on the feature is complete. You can commit to this individual branch as much as you like and push continuously to the remote repo, ensuring that no work is ever lost. When development work is complete, you can then locally rebase your individual branch's commits, merge the individual branch into the feature branch (not using a PR), and then merge the feature branch into develop using a PR. The individual branch can then be deleted. So, for one developer named Alice, the full workflow would be as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 git checkout develop git pull git checkout -b feature/ABC-2701_cool_new_feature git push -u origin head git checkout -b alice/ABC-2701_cool_new_feature git push -u origin head ## Do work on the feature and continuously commit and push changes on the # individual branch to the remote repo git add -A git commit -m 'My commit message 1' # Do some more work git add -A git commit -m 'My commit message 2' # Finally, when all work is done, rebase and merge. See the section below on # [interactive rebasing](#interactive-rebasing-ensuring-a-clean-commit-history) git rebase -i HEAD~2 # After finishing the rebase, switch to the feature branch and merge git checkout feature/ABC-2701_cool_new_feature git pull git merge alice/ABC-2701_cool_new_feature git push git br -d alice/ABC-2701_cool_new_feature In Jira, tickets are organized into boards , which are areas where a team can keep track of all of its open tickets. For more information, see here . \u21a9 A pull request is a way to submit code changes for review and request that they be merged into a branch. For more info, see here . \u21a9","title":"Using GitFlow to improve your git workflow"},{"location":"2019/gitflow/#using-gitflow-to-improve-your-git-workflow","text":"","title":"Using GitFlow to improve your git workflow"},{"location":"2019/gitflow/#intro","text":"GitFlow is a basic git workflow created by Vincent Driessen and described in his blog post here . I've been using a modified version of GitFlow for a while now, and thought it would be a good thing to talk about here. In this post, I'm going to describe GitFlow and talk about a couple additional things I do when using it. Disclaimer GitFlow isn't for everyone. It works best when your deployment cycle is based around releases. If your team deploys to production every day or several times a day, GitFlow may be impractical. In this case, github flow might be a better, more lightweight alternative.","title":"Intro"},{"location":"2019/gitflow/#basic-gitflow","text":"Fig. 1: Image taken from here .","title":"Basic GitFlow"},{"location":"2019/gitflow/#development-lifecycle","text":"The basic GitFlow is outlined in Fig. 1. GitFlow assumes that your deployment lifecycle is like the following: Work is divided into sprints During a sprint, developers will work on a handful of features When all of the sprint's features are finished, they will be packaged into a release That release is then deployed to production GitFlow helps to accomplish this by having designated branches that correspond to the different stages of this lifecycle.","title":"Development lifecycle"},{"location":"2019/gitflow/#branches","text":"Each repo should have two persistent branches which live forever: develop and master . master contains the code for the release which is currently deployed to production. It should never contain anything which is not released. Anything in master, at any given time, is working production code, and every commit to master is a new release. develop contains code for the next release. During a sprint, new features are added to develop until the sprint ends. In addition to develop and master , there are several short-lived branches which are created for a purpose and then deleted once that purpose is served: Feature branches are used to work on a new feature. They are forked off of develop and then merged back into develop and deleted when complete. Release branches contain all the new features which will be deployed to production in a release. A release branch is basically a bunch of features which will be merged into master at the same time. When a sprint ends, a release branch is forked from develop and then merged back into master and develop . A hotfix is a small change that needs to be made immediately and requires minimal or no testing. A hotfix branch is forked from master and then merged back into develop and master .","title":"Branches"},{"location":"2019/gitflow/#working-with-gitflow-step-by-step-code-walkthrough","text":"I will now describe what commands you can use to follow GitFlow with your own projects.","title":"Working with gitflow: step by step code walkthrough"},{"location":"2019/gitflow/#starting-a-project","text":"","title":"Starting a project"},{"location":"2019/gitflow/#creating-a-new-repo","text":"If you're starting a new project from scratch, you can create a repo for your project and then clone it to your local. Then create the develop branch off of master , and push it to the remote: 1 2 3 4 git clone <repo address> /path/on/local cd /path/on/local git checkout -b develop git push -u origin head","title":"Creating a new repo"},{"location":"2019/gitflow/#working-with-an-existing-repo","text":"If a repo for your project already exists, clone the repo to your local: 1 git clone <repo address> /path/on/local","title":"Working with an existing repo"},{"location":"2019/gitflow/#working-on-a-new-feature","text":"Each feature should correspond to a single ticket in Jira , or whatever software you use to track tickets. All code changes for that ticket should be contained in a single feature branch with the naming convention: feature/<board_name>-<ticket_nunmber>_<ticket_description> 1 . Let's say your team uses a Jira board named ABC In that case, an example feature branch name would be: feature/ABC-2701_cool_new_feature . All Jira tickets should have their own feature branch so that feature branches contain just the minimum code changes needed to close out their corresponding ticket. The following is a step-by-step guide to working on a new feature.","title":"Working on a new feature"},{"location":"2019/gitflow/#one-developer-working-on-a-feature","text":"","title":"One developer working on a feature"},{"location":"2019/gitflow/#step-1-create-a-feature-branch","text":"Let's say you're the only developer working on the feature ABC-2701_cool_new_feature . Create a feature branch from develop and then push the branch: 1 2 3 4 5 6 git checkout develop # Make sure you have the latest changes to develop git pull git checkout -b feature/ABC-2701_cool_new_feature # Set -u (upstream) so that git remembers what remote to push to on this branch git push -u origin head","title":"Step 1: Create a feature branch"},{"location":"2019/gitflow/#step-2-work-on-the-feature-and-push-to-remote","text":"Once all work is done on the feature, commit your changes and push to the remote repository. Note Before pushing, it's a good idea to make sure you have a clean commit history. Follow the instructions in my blog post on interactive rebasing to ensure that your commit history is clean before merging. 1 2 3 4 5 6 7 8 # Make sure you're on the feature branch git checkout feature/ABC-2701_cool_new_feature # Pull in latest changes git pull # Ensure your changes are compatible with current develop before pushing git merge develop # No need to specify origin head if you did -u earlier git push Note You may need to resolve some merge conflicts at this stage. I recommend DiffMerge for this.","title":"Step 2: Work on the feature and push to remote"},{"location":"2019/gitflow/#step-3-pr-from-feature-branch-into-develop","text":"To merge the feature branch, open a pull request (PR) 2 into develop . Once the PR is approved, merge it and then delete the feature branch on the remote.","title":"Step 3: PR from feature branch into develop"},{"location":"2019/gitflow/#step-4-clean-up-local-branches","text":"Finally, clean up your local branches: 1 2 3 4 5 git checkout develop git pull git br -d feature/ABC-2701_cool_new_feature # Prune the inactive remote branches git fetch -p The feature is now complete.","title":"Step 4: Clean up local branches"},{"location":"2019/gitflow/#multiple-developers-working-on-a-feature","text":"If more than one developer is working on the same feature, the process is only slightly more complicated than if one developer is working on the feature. Let's say Alice, Bob, and Carol are all working on the feature from above. The following is how they would each work together.","title":"Multiple developers working on a feature"},{"location":"2019/gitflow/#step-1-create-a-feature-branch_1","text":"Same as in the one developer scenario, make a feature branch from develop . 1 2 3 4 git checkout develop git pull git checkout -b feature/ABC-2701_cool_new_feature git push -u origin head","title":"Step 1: Create a feature branch"},{"location":"2019/gitflow/#step-2-each-developer-creates-an-individual-branch","text":"Rather than all work on the main feature branch, Alice, Bob, and Carol should all create their own individual branches to work on from the main feature branch. This way, all of their changes are separated. On Alice's local: 1 2 3 4 git checkout feature/ABC-2701_cool_new_feature git pull git checkout -b alice/ABC-2701_cool_new_feature git push -u origin head On Bob's local: 1 2 3 4 git checkout feature/ABC-2701_cool_new_feature git pull git checkout -b bob/ABC-2701_cool_new_feature git push -u origin head On Carol's local: 1 2 3 4 git checkout feature/ABC-2701_cool_new_feature git pull git checkout -b carol/ABC-2701_cool_new_feature git push -u origin head","title":"Step 2: Each developer creates an individual branch"},{"location":"2019/gitflow/#step-3-individual-work-and-push-to-remote","text":"Each developer can work on their individual branch. Once a developer is done with their share of the work, they should merge their individual branch into the main feature branch with a PR, while making sure all merge conflicts are resolved. So, if Alice finishes her portion of the ticket, she would do: 1 2 3 4 5 6 7 8 9 # Make sure she's on her individual branch git checkout alice/ABC-2701_cool_new_feature # Pull in latest changes git pull # Merge in the latest changes from the other developers and from develop git merge bob/ABC-2701_cool_new_feature git merge carol/ABC-2701_cool_new_feature git merge develop git push As in the earlier case, make sure all merge conflicts are resolved before pushing. Note Just as in the one developer case, at this stage it is a good idea to rebase your commit history before pushing to the remeote. Follow the instructions here to do that.","title":"Step 3: Individual work and push to remote"},{"location":"2019/gitflow/#step-4-pr-from-individual-branch-into-main-feature-branch","text":"Once all conflicts are done and merges complete, Alice should create a PR for her feature branch into the main feature branch. Once the PR is approved, merge it, and then delete the individual branch on the remote.","title":"Step 4: PR from individual branch into main feature branch"},{"location":"2019/gitflow/#step-5-repeat-for-other-developers","text":"Bob and Carol should repeat steps 3 and 4 for their individual branches.","title":"Step 5: Repeat for other developers"},{"location":"2019/gitflow/#step-6-pr-from-feature-branch-into-develop","text":"When all individual branches are merged into the main feature branch, the next step is to merge the feature branch into develop. First, ensure that any updates to develop are pulled into the feature branch: 1 2 3 4 git checkout feature/ABC-2701_cool_new_feature git pull git merge develop git push Then create a PR from feature/ABC-2701_cool_new_feature into develop . When that is approved, merge the PR and then delete the feature branch from the remote repo.","title":"Step 6: PR from feature branch into develop"},{"location":"2019/gitflow/#step-7-clean-up-local-branches","text":"Finally, clean up your local branches: 1 2 3 4 5 git checkout develop git pull git br -d feature/ABC-2701_cool_new_feature # Prune the inactive remote branches git fetch -p The feature is now complete.","title":"Step 7: Clean up local branches"},{"location":"2019/gitflow/#cutting-a-release-branch","text":"When you are finished working on all of the features for a release, cut a new release branch off of develop , then merge it into master and develop . Branches are named according to semantic versioning : MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, and PATCH version when you make backwards compatible bug fixes. 1 2 3 4 git checkout develop git pull git checkout -b release/1.0.0 git push -u origin head Then merge the branch into master with a PR, and delete the release branch in the remote and locally: 1 2 3 4 git checkout develop git pull git br -d release/1.0.0 git fetch -p You have now released a new release.","title":"Cutting a release branch"},{"location":"2019/gitflow/#appendix","text":"","title":"Appendix"},{"location":"2019/gitflow/#one-developer-optional-variation-using-an-individual-branch","text":"In the above section on GitFlow for one developer , it calls for that developer to create a feature branch, work on it, and then eventually merge that feature branch back into develop with a PR. Ideally, before a branch is merged, its commit history should be clean by following the steps in my interactive rebasing post . However, because rebasing involves rewriting history, it's best not to rebase commits on branches that have already been pushed to a remote repository. This leaves two options. The first option is to do all work on your feature branch locally and only push to the remote once work on the branch is complete and the commit log has been rebased locally. This is okay for features that do not take a long time to complete; however, for features that take many days to complete, it is not ideal. A better approach is to create an individual branch, forked off of the feature branch, and work on that branch until development on the feature is complete. You can commit to this individual branch as much as you like and push continuously to the remote repo, ensuring that no work is ever lost. When development work is complete, you can then locally rebase your individual branch's commits, merge the individual branch into the feature branch (not using a PR), and then merge the feature branch into develop using a PR. The individual branch can then be deleted. So, for one developer named Alice, the full workflow would be as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 git checkout develop git pull git checkout -b feature/ABC-2701_cool_new_feature git push -u origin head git checkout -b alice/ABC-2701_cool_new_feature git push -u origin head ## Do work on the feature and continuously commit and push changes on the # individual branch to the remote repo git add -A git commit -m 'My commit message 1' # Do some more work git add -A git commit -m 'My commit message 2' # Finally, when all work is done, rebase and merge. See the section below on # [interactive rebasing](#interactive-rebasing-ensuring-a-clean-commit-history) git rebase -i HEAD~2 # After finishing the rebase, switch to the feature branch and merge git checkout feature/ABC-2701_cool_new_feature git pull git merge alice/ABC-2701_cool_new_feature git push git br -d alice/ABC-2701_cool_new_feature In Jira, tickets are organized into boards , which are areas where a team can keep track of all of its open tickets. For more information, see here . \u21a9 A pull request is a way to submit code changes for review and request that they be merged into a branch. For more info, see here . \u21a9","title":"One developer optional variation: using an individual branch"},{"location":"2019/rebasing/","text":"Using interactive rebase to ensure a clean git history \u00b6 The problem \u00b6 Sometimes, when working on a feature branch, your commit history can get messy. If your log looks like this: 1 2 3 4 926bdc9 - 8 minutes ago : OK, now it's fixed b8ae898 - 10 minutes ago : Now it's really fixed 564f4db - 15 minutes ago : Fixed a small mistake 0fac50d - 20 minutes ago : Added a new feature you should consider revising your commit history before pushing to a remote repo. To do this, you can do an interactive rebase . Rebasing \u00b6 Rebasing is a git tool for rewriting your commit history. Using rebase , you can squash multiple commits together into one, resulting in a cleaner commit history that looks like this: 1 926bdc9 - 8 minutes ago : Added a new feature To do this, run: 1 git rebase -i HEAD~4 The -i flag runs the rebase interactively, and HEAD~4 means that the rebase will allow you to edit the last 4 commits. This command will open up an interactive rebase vim window with the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 pick 926 bdc9 OK , now it 's fixed pick b8ae898 Now it' s really fixed pick 564 f4db Fixed a small mistake pick 0 fac50d Added a new feature # Rebase ad5b2e0 .. 6695 e26 onto 559 b098 ( 5 commands ) # # Commands : # p , pick < commit > = use commit # r , reword < commit > = use commit , but edit the commit message # e , edit < commit > = use commit , but stop for amending # s , squash < commit > = use commit , but meld into previous commit # f , fixup < commit > = like \"squash\" , but discard this commit 's log message # x, exec <command> = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with ' git rebase --continue') # d , drop < commit > = remove commit # l , label < label > = label current HEAD with a name # t , reset < label > = reset HEAD to a label # m , merge [ - C < commit > | - c < commit > ] < label > [ # < oneline > ] # . create a merge commit using the original merge commit ' s # . message ( or the oneline , if no original merge commit was # . specified ). Use - c < commit > to reword the commit message . # # These lines can be re - ordered ; they are executed from top to bottom . # # If you remove a line here THAT COMMIT WILL BE LOST . # # However , if you remove everything , the rebase will be aborted . # # Note that empty commits are commented out To squash all four of these commits into one, pick the top commit, and squash the lower three: 1 2 3 4 pick 926bdc9 OK, now it's fixed squash b8ae898 Now it's really fixed squash 564f4db Fixed a small mistake squash 0fac50d Added a new feature Then exit the rebase window with :wq . This will open a new vim window where you can view and edit the commit messages of the commits you are rebasing: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # This is a combination of 5 commits . # This is the 1 st commit message : Added a new feature # This is the commit message # 2 : Fixed a small mistake # This is the commit message # 3 : Now it 's really fixed # This is the commit message #4: OK, now it' s fixed # Please enter the commit message for your changes . Lines starting # with '#' will be ignored , and an empty message aborts the commit . # # Date : Sun Nov 24 22 : 05 : 15 2019 - 0600 # # interactive rebase in progress ; onto ad5b2e0 # Last commands done ( 5 commands done ): # squash 559 b098 4 # squash 6695 e26 5 # No commands remaining . # You are currently rebasing branch 'feature/DAT-2701_cool_new_feature' on 'ad5b2e0' . # # Changes to be committed : # new file : a . txt # new file : b . txt # new file : c . txt # new file : d . txt You can delete everything above the #Please enter line and rewrite a new commit message, and then :wq the file. Now your commit history is clean and you can push to the remote with a neatly organized commit log.","title":"Using interactive rebase to ensure a clean git history"},{"location":"2019/rebasing/#using-interactive-rebase-to-ensure-a-clean-git-history","text":"","title":"Using interactive rebase to ensure a clean git history"},{"location":"2019/rebasing/#the-problem","text":"Sometimes, when working on a feature branch, your commit history can get messy. If your log looks like this: 1 2 3 4 926bdc9 - 8 minutes ago : OK, now it's fixed b8ae898 - 10 minutes ago : Now it's really fixed 564f4db - 15 minutes ago : Fixed a small mistake 0fac50d - 20 minutes ago : Added a new feature you should consider revising your commit history before pushing to a remote repo. To do this, you can do an interactive rebase .","title":"The problem"},{"location":"2019/rebasing/#rebasing","text":"Rebasing is a git tool for rewriting your commit history. Using rebase , you can squash multiple commits together into one, resulting in a cleaner commit history that looks like this: 1 926bdc9 - 8 minutes ago : Added a new feature To do this, run: 1 git rebase -i HEAD~4 The -i flag runs the rebase interactively, and HEAD~4 means that the rebase will allow you to edit the last 4 commits. This command will open up an interactive rebase vim window with the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 pick 926 bdc9 OK , now it 's fixed pick b8ae898 Now it' s really fixed pick 564 f4db Fixed a small mistake pick 0 fac50d Added a new feature # Rebase ad5b2e0 .. 6695 e26 onto 559 b098 ( 5 commands ) # # Commands : # p , pick < commit > = use commit # r , reword < commit > = use commit , but edit the commit message # e , edit < commit > = use commit , but stop for amending # s , squash < commit > = use commit , but meld into previous commit # f , fixup < commit > = like \"squash\" , but discard this commit 's log message # x, exec <command> = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with ' git rebase --continue') # d , drop < commit > = remove commit # l , label < label > = label current HEAD with a name # t , reset < label > = reset HEAD to a label # m , merge [ - C < commit > | - c < commit > ] < label > [ # < oneline > ] # . create a merge commit using the original merge commit ' s # . message ( or the oneline , if no original merge commit was # . specified ). Use - c < commit > to reword the commit message . # # These lines can be re - ordered ; they are executed from top to bottom . # # If you remove a line here THAT COMMIT WILL BE LOST . # # However , if you remove everything , the rebase will be aborted . # # Note that empty commits are commented out To squash all four of these commits into one, pick the top commit, and squash the lower three: 1 2 3 4 pick 926bdc9 OK, now it's fixed squash b8ae898 Now it's really fixed squash 564f4db Fixed a small mistake squash 0fac50d Added a new feature Then exit the rebase window with :wq . This will open a new vim window where you can view and edit the commit messages of the commits you are rebasing: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # This is a combination of 5 commits . # This is the 1 st commit message : Added a new feature # This is the commit message # 2 : Fixed a small mistake # This is the commit message # 3 : Now it 's really fixed # This is the commit message #4: OK, now it' s fixed # Please enter the commit message for your changes . Lines starting # with '#' will be ignored , and an empty message aborts the commit . # # Date : Sun Nov 24 22 : 05 : 15 2019 - 0600 # # interactive rebase in progress ; onto ad5b2e0 # Last commands done ( 5 commands done ): # squash 559 b098 4 # squash 6695 e26 5 # No commands remaining . # You are currently rebasing branch 'feature/DAT-2701_cool_new_feature' on 'ad5b2e0' . # # Changes to be committed : # new file : a . txt # new file : b . txt # new file : c . txt # new file : d . txt You can delete everything above the #Please enter line and rewrite a new commit message, and then :wq the file. Now your commit history is clean and you can push to the remote with a neatly organized commit log.","title":"Rebasing"}]}