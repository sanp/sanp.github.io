{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Sanp's blog \u00b6 What is this? \u00b6 This is a blog where I write about random techy / programming things I'm doing. Learn more about me in my About section. Posts \u00b6 Check out the latest posts by going to the side panel nav bar and seeing what's in this year's folder. Blog stack \u00b6 To make this blog, I'm using: mkdocs , a static site framework The material for mkdocs theme Several material for mkdocs extensions The mkdocs-macros plugin Github pages to host At some point, maybe I'll do posts on each of these. For now, you can find more info at their respective websites.","title":"Home"},{"location":"#welcome-to-sanps-blog","text":"","title":"Welcome to Sanp's blog"},{"location":"#what-is-this","text":"This is a blog where I write about random techy / programming things I'm doing. Learn more about me in my About section.","title":"What is this?"},{"location":"#posts","text":"Check out the latest posts by going to the side panel nav bar and seeing what's in this year's folder.","title":"Posts"},{"location":"#blog-stack","text":"To make this blog, I'm using: mkdocs , a static site framework The material for mkdocs theme Several material for mkdocs extensions The mkdocs-macros plugin Github pages to host At some point, maybe I'll do posts on each of these. For now, you can find more info at their respective websites.","title":"Blog stack"},{"location":"about/","text":"About Me \u00b6 Hi, I'm Steve ( @sanp ) \u00b6 I'm a Software Engineer in Chicago and I'm interested in python , vim / neovim , scala , SQL , spark , AWS, and big data. I'm also interested in learning more about functional programming, and I do some basic web development. Links \u00b6 Link to my github . Link to my dotfiles .","title":"About"},{"location":"about/#about-me","text":"","title":"About Me"},{"location":"about/#hi-im-steve-sanp","text":"I'm a Software Engineer in Chicago and I'm interested in python , vim / neovim , scala , SQL , spark , AWS, and big data. I'm also interested in learning more about functional programming, and I do some basic web development.","title":"Hi, I'm Steve (@sanp)"},{"location":"about/#links","text":"Link to my github . Link to my dotfiles .","title":"Links"},{"location":"2019/gitflow_1/","text":"Gitflow Part 1: Overview of Gitflow \u00b6 Abstract Welcome to part one of a two part series on GitFlow. When you're done reading part one, check out part two. Gitflow Part 1: Overview of Gitflow Gitflow Part 2: Step by step guide to Working on a feature Intro \u00b6 GitFlow is a basic git workflow created by Vincent Driessen and described in his blog post here . I've been using a modified version of GitFlow for a while now, and thought it would be a good thing to talk about on this blog. In part one of this two-part series, I'm going to describe GitFlow and talk about how it fits into a team's development lifecycle. In part two I'll discuss working on a new feature, and give a step-by-step breakdown of what commands to use when working on a new feature. Disclaimer GitFlow isn't for everyone. It works best when your deployment cycle is based around releases. If your team deploys to production every day or several times a day, GitFlow may be impractical. In this case, github flow might be a better, more lightweight alternative. GitFlow Overview \u00b6 Fig. 1: Image taken from here . Development lifecycle \u00b6 The basic GitFlow is outlined in Fig. 1. GitFlow assumes that your deployment lifecycle is like the following: Work is divided into sprints During a sprint, developers will work on a handful of features When all of the sprint's features are finished, they will be packaged into a release That release is then deployed to production GitFlow helps to accomplish this by having designated branches that correspond to the different stages of this lifecycle. Branches \u00b6 Each repo should have two persistent branches which live forever: develop and master . master contains the code for the release which is currently deployed to production. It should never contain anything which is not released. Anything in master, at any given time, is working production code, and every commit to master is a new release. develop contains code for the next release. During a sprint, new features are added to develop until the sprint ends. In addition to develop and master , there are several short-lived branches which are created for a purpose and then deleted once that purpose is served: Feature branches are used to work on a new feature. They are forked off of develop and then merged back into develop and deleted when work on the feature is complete. Release branches contain all the new features which will be deployed to production in a release. A release branch is basically a bunch of features which will be merged into master at the same time. When a sprint ends, a release branch is forked from develop and then merged back into master and develop . A hotfix is a change that needs to be made immediately. They differ from normal bug fixes in that they can't wait for the next release to be deployed to production. A hotfix branch is forked from master and then merged back into develop and master . Starting a project \u00b6 If you're starting a new project from scratch, you can create a repository for your project and then clone it to your local. Then create the develop branch off of master , and push it to the remote: 1 2 3 4 5 git clone <repo address> /path/on/local cd /path/on/local git checkout -b develop # Set -u (upstream) so that git remembers what remote to push to on this branch git push -u origin head Working on a feature \u00b6 To work on a new feature, fork a feature branch off of develop , as shown in Fig. 1. Once all coding and testing are done, you can merge the feature branch back into develop . The specific commands for how to work on a feature branch and merge it back into develop are described in part two of this series. Releasing features \u00b6 When you are finished working on all of the features for a release, cut a new release branch off of develop . A good way to name releases is with semantic versioning : MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, and PATCH version when you make backwards compatible bug fixes. And a good naming convention for release branches is release/{release number} . So, if you are releasing version 1.2.3 , you can fork a release branch off of develop: 1 2 3 git checkout develop git pull git checkout -b release/1.2.3 Note As shown in Fig. 1, sometimes after creating a new release, you might notice a bug that needs to be fixed before merging the release branch. In this case, you can fix the bug with a new commit to the release branch, as shown in the diagram. Then, to actually release the release, merge it into master and develop using pull requests (PRs) 1 : create one PR from release/1.2.3 into master and create a second PR from release/1.2.3 into develop . Once these PRs are merged, you can then tag the commits in master with the version number, and then push the tag to the remote: 1 2 3 4 git checkout master git pull git tag 1 .2.3 git push origin 1 .2.3 Making a hotfix \u00b6 To make a hotfix, fork a branch off of master and then merge it back into develop and master , as shown in Fig. 1. Since hotfixes are ultimately merged back into master , they are also new releases (since every commit to master is a new release). Therefore, like release branches, hotfixes should also have a release number. Further, because hotfixes are generally small changes, the release version number for a hotfix should usually just increment the patch number of the version which is currently in master . If the change is big enough to increment the major or minor version number, it probably shouldn't be a hotfix. Hotfix branches should be named with the naming convention: hotfix/{release-number} . So, if the current version released in master is version 1.2.3 , your hotfix should be version 1.2.4 , and the branch should be named hotfix/1.2.4 . Once the hotfix is completed, follow the same steps for releasing a new release: merge the hotfix branch into both develop and master with two PRs, and then tag the commits with the new release number. Conclusion \u00b6 The above was an overview of my take on GitFlow and how it incorporates into a full development lifecycle. This is not the only way to do GitFlow; in fact, I've made a few changes from Vincent Driessen's original post on GitFlow. GitFlow is more of a general workflow and you should feel free to tweak it to fit your team's needs. Note Now that you've finished part one of this series, take a look at part two . A pull request is a way to submit code changes for review and request that they be merged into a branch. For more info, see here . \u21a9","title":"Gitflow Part 1: Overview of Gitflow"},{"location":"2019/gitflow_1/#gitflow-part-1-overview-of-gitflow","text":"Abstract Welcome to part one of a two part series on GitFlow. When you're done reading part one, check out part two. Gitflow Part 1: Overview of Gitflow Gitflow Part 2: Step by step guide to Working on a feature","title":"Gitflow Part 1: Overview of Gitflow"},{"location":"2019/gitflow_1/#intro","text":"GitFlow is a basic git workflow created by Vincent Driessen and described in his blog post here . I've been using a modified version of GitFlow for a while now, and thought it would be a good thing to talk about on this blog. In part one of this two-part series, I'm going to describe GitFlow and talk about how it fits into a team's development lifecycle. In part two I'll discuss working on a new feature, and give a step-by-step breakdown of what commands to use when working on a new feature. Disclaimer GitFlow isn't for everyone. It works best when your deployment cycle is based around releases. If your team deploys to production every day or several times a day, GitFlow may be impractical. In this case, github flow might be a better, more lightweight alternative.","title":"Intro"},{"location":"2019/gitflow_1/#gitflow-overview","text":"Fig. 1: Image taken from here .","title":"GitFlow Overview"},{"location":"2019/gitflow_1/#development-lifecycle","text":"The basic GitFlow is outlined in Fig. 1. GitFlow assumes that your deployment lifecycle is like the following: Work is divided into sprints During a sprint, developers will work on a handful of features When all of the sprint's features are finished, they will be packaged into a release That release is then deployed to production GitFlow helps to accomplish this by having designated branches that correspond to the different stages of this lifecycle.","title":"Development lifecycle"},{"location":"2019/gitflow_1/#branches","text":"Each repo should have two persistent branches which live forever: develop and master . master contains the code for the release which is currently deployed to production. It should never contain anything which is not released. Anything in master, at any given time, is working production code, and every commit to master is a new release. develop contains code for the next release. During a sprint, new features are added to develop until the sprint ends. In addition to develop and master , there are several short-lived branches which are created for a purpose and then deleted once that purpose is served: Feature branches are used to work on a new feature. They are forked off of develop and then merged back into develop and deleted when work on the feature is complete. Release branches contain all the new features which will be deployed to production in a release. A release branch is basically a bunch of features which will be merged into master at the same time. When a sprint ends, a release branch is forked from develop and then merged back into master and develop . A hotfix is a change that needs to be made immediately. They differ from normal bug fixes in that they can't wait for the next release to be deployed to production. A hotfix branch is forked from master and then merged back into develop and master .","title":"Branches"},{"location":"2019/gitflow_1/#starting-a-project","text":"If you're starting a new project from scratch, you can create a repository for your project and then clone it to your local. Then create the develop branch off of master , and push it to the remote: 1 2 3 4 5 git clone <repo address> /path/on/local cd /path/on/local git checkout -b develop # Set -u (upstream) so that git remembers what remote to push to on this branch git push -u origin head","title":"Starting a project"},{"location":"2019/gitflow_1/#working-on-a-feature","text":"To work on a new feature, fork a feature branch off of develop , as shown in Fig. 1. Once all coding and testing are done, you can merge the feature branch back into develop . The specific commands for how to work on a feature branch and merge it back into develop are described in part two of this series.","title":"Working on a feature"},{"location":"2019/gitflow_1/#releasing-features","text":"When you are finished working on all of the features for a release, cut a new release branch off of develop . A good way to name releases is with semantic versioning : MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, and PATCH version when you make backwards compatible bug fixes. And a good naming convention for release branches is release/{release number} . So, if you are releasing version 1.2.3 , you can fork a release branch off of develop: 1 2 3 git checkout develop git pull git checkout -b release/1.2.3 Note As shown in Fig. 1, sometimes after creating a new release, you might notice a bug that needs to be fixed before merging the release branch. In this case, you can fix the bug with a new commit to the release branch, as shown in the diagram. Then, to actually release the release, merge it into master and develop using pull requests (PRs) 1 : create one PR from release/1.2.3 into master and create a second PR from release/1.2.3 into develop . Once these PRs are merged, you can then tag the commits in master with the version number, and then push the tag to the remote: 1 2 3 4 git checkout master git pull git tag 1 .2.3 git push origin 1 .2.3","title":"Releasing features"},{"location":"2019/gitflow_1/#making-a-hotfix","text":"To make a hotfix, fork a branch off of master and then merge it back into develop and master , as shown in Fig. 1. Since hotfixes are ultimately merged back into master , they are also new releases (since every commit to master is a new release). Therefore, like release branches, hotfixes should also have a release number. Further, because hotfixes are generally small changes, the release version number for a hotfix should usually just increment the patch number of the version which is currently in master . If the change is big enough to increment the major or minor version number, it probably shouldn't be a hotfix. Hotfix branches should be named with the naming convention: hotfix/{release-number} . So, if the current version released in master is version 1.2.3 , your hotfix should be version 1.2.4 , and the branch should be named hotfix/1.2.4 . Once the hotfix is completed, follow the same steps for releasing a new release: merge the hotfix branch into both develop and master with two PRs, and then tag the commits with the new release number.","title":"Making a hotfix"},{"location":"2019/gitflow_1/#conclusion","text":"The above was an overview of my take on GitFlow and how it incorporates into a full development lifecycle. This is not the only way to do GitFlow; in fact, I've made a few changes from Vincent Driessen's original post on GitFlow. GitFlow is more of a general workflow and you should feel free to tweak it to fit your team's needs. Note Now that you've finished part one of this series, take a look at part two . A pull request is a way to submit code changes for review and request that they be merged into a branch. For more info, see here . \u21a9","title":"Conclusion"},{"location":"2019/gitflow_2/","text":"Gitflow Part 2: Step by step guide to Working on a feature \u00b6 Abstract Welcome to part two of my series on GitFlow. If you're just getting here, check out part one first. Gitflow Part 1: Overview of Gitflow Gitflow Part 2: Step by step guide to Working on a feature GitFlow and Jira \u00b6 Before going through the step by step guide, I want to mention how GitFlow fits into the larger project management context. GitFlow works well in conjunction with a ticket tracking software. There are plenty of tracking tools out there, such as Jira or Trello . Whatever tool you use, though, each feature you work on should correspond to a single ticket which is tracked in your tool of choice. In Jira, for example, tickets are organized into boards , which are areas where a team can keep track of all of its open tickets. When working on a new feature, I like to create feature branches with the naming convention: 1 feature/<board_name>-<ticket_nunmber>_<ticket_description> For example, say you have a Jira board named ABC . If you're working on implementing a \"cool new feature,\" you can make a ticket in your ABC board named \"Cool New Feature,\" and then create a feature branch named feature/ABC-101_cool_new_feature . Working on a new feature: step by step guide \u00b6 In Vincent Driessen's original post on GitFlow, the basic process he described for working on a feature can be broken down into four main steps: Create a feature branch off of develop Work on that branch and push it to the remote repo Merge the feature branch into develop Clean up your branches This process works great for small features, but in my experience, it has one main drawback: it makes keeping a clean commit history more difficult. Ideally, before merging any branch, you should clean up your commit history by following the steps in my interactive rebasing post . However, because rebasing involves rewriting history, it's best not to rebase commits on branches that have already been pushed to a remote repository. This presents a slight problem when using GitFlow. If you're working on a feature branch that takes several days or even weeks to complete, you'll naturally want to push your changes to a remote periodically to ensure you don't lose any work if your laptop crashes. However, if you do this, then rebasing is trickier since you would be rewriting published history. The best solution I've found is to do all of your feature work on an intermediate individual branch first, and then merge that branch into your feature branch. The basic workflow then becomes slightly more involved: Create a feature branch off of develop Create an individual branch off of the feature branch Work on the individual branch, pushing to the remote often to avoid losing history When work on the feature is complete, merge the individual branch into the feature branch Then merge the feature branch into develop Clean up your branches In the next sections, I'm going to go over each of these steps, and show the commands necessary to execute them. Step 1: Create a feature branch \u00b6 Let's say you're a developer working on the feature ABC-101_cool_new_feature . Create a feature branch from develop and then push the branch: 1 2 3 4 5 6 git checkout develop # Make sure you have the latest changes to develop git pull git checkout -b feature/ABC-101_cool_new_feature # Set -u (upstream) so that git remembers what remote to push to on this branch git push -u origin head Step 2: Create an individual branch off of the feature branch \u00b6 To make your intermediate branch, fork a branch off of the feature branch you just created. For the individual branches, I like to use the naming convention: 1 <your-name>/<feature-branch-name-after-slash> So, if Alice is working on the feature/ABC-101_cool_new_feature branch, then she would make an individual branch named alice/ABC-101_cool_new_feature : 1 2 3 4 # Make sure you're on the feature/ABC-101_cool_new_feature branch git checkout feature/ABC-101_cool_new_feature branch git checkout -b alice/ABC-101_cool_new_feature git push -u origin head Step 3: Work on the individual branch and push to remote often \u00b6 Now that Alice has her individual branch set up, she can work on it and push to the remote as often as she likes. I usually make several commits per day and push to the remote once at the end of each day. But you can feel free to push as often as you like: you never know when your laptop will crash and you'll lose important work! 1 2 3 4 5 6 7 8 # Do work on the feature and continuously commit changes on the individual # branch and push to the remote git add -A git commit -m 'My commit message 1' # Do some more work git add -A git commit -m 'My commit message 2' git push Step 4: Merge the individual branch back into the feature branch \u00b6 Once all work is done on the feature, commit your changes and push to the remote copy of your individual branch one last time. The next step is to merge your individual branch into the feature branch. Before merging, though, you'll want to make sure you have a clean commit history. Your individual branch likely has tens of commits at this point, many of which have unhelpful commit messages such as \"Fixed a typo\" or \"Made a small update.\" Rather than keep all of these as separate commits, you should squash these into one or a few more meaningful commits before merging. To do this, you can follow the instructions in my blog post on interactive rebasing. Once you have cleaned your commit history, then merge the individual branch into the feature branch. You'll also want to merge in develop to the feature branch as well, to make sure there are no merge conflicts between your feature code and what's already pushed in develop . 1 2 3 4 5 git checkout feature/ABC-101_cool_new_feature git pull git merge alice/ABC-101_cool_new_feature git merge develop git push Note You may need to resolve some merge conflicts at this stage. To do this, you can use a merge tool such as DiffMerge . You can also use Tim Pope's fugitive plugin to handle merge conflicts. For more info on how to do that, see this screencast . Step 5: PR from feature branch into develop \u00b6 Step five is to merge the feature branch into develop . To merge the feature branch, you can use a pull request (PR). A PR is a way to submit code changes for review and request that they be merged into a branch. Once the PR is approved, merge it and then delete the feature branch on the remote. Step 6: Clean up local branches \u00b6 Once the PR is merged, then work on the feature is almost complete. The last step is to clean up your local branch list by deleting the old branches. Note You can use git fetch -p to prune your remote branch list to remove any remote branches you're tracking that no longer exist. 1 2 3 4 5 6 git checkout develop git pull git branch -d alice/ABC-101_cool_new_feature git branch -d feature/ABC-101_cool_new_feature # Prune the inactive remote branches git fetch -p The feature is now complete. Conclusion \u00b6 The above shouldn't be taken as the definitive guide or the only way to do GitFlow. This is just a method of working on features that has worked well for me in the past. Depending on the circumstance, you might find yourself wanting to adjust this workflow. For example, if you have a very small feature which will only take a day or two, you can of course skip creating an individual branch to work on and just work directly on the feature branch. Like anything related to workflow, you should design a workflow that fits your needs, not shoehorn your needs into a particular workflow.","title":"Gitflow Part 2: Step by step guide to Working on a feature"},{"location":"2019/gitflow_2/#gitflow-part-2-step-by-step-guide-to-working-on-a-feature","text":"Abstract Welcome to part two of my series on GitFlow. If you're just getting here, check out part one first. Gitflow Part 1: Overview of Gitflow Gitflow Part 2: Step by step guide to Working on a feature","title":"Gitflow Part 2: Step by step guide to Working on a feature"},{"location":"2019/gitflow_2/#gitflow-and-jira","text":"Before going through the step by step guide, I want to mention how GitFlow fits into the larger project management context. GitFlow works well in conjunction with a ticket tracking software. There are plenty of tracking tools out there, such as Jira or Trello . Whatever tool you use, though, each feature you work on should correspond to a single ticket which is tracked in your tool of choice. In Jira, for example, tickets are organized into boards , which are areas where a team can keep track of all of its open tickets. When working on a new feature, I like to create feature branches with the naming convention: 1 feature/<board_name>-<ticket_nunmber>_<ticket_description> For example, say you have a Jira board named ABC . If you're working on implementing a \"cool new feature,\" you can make a ticket in your ABC board named \"Cool New Feature,\" and then create a feature branch named feature/ABC-101_cool_new_feature .","title":"GitFlow and Jira"},{"location":"2019/gitflow_2/#working-on-a-new-feature-step-by-step-guide","text":"In Vincent Driessen's original post on GitFlow, the basic process he described for working on a feature can be broken down into four main steps: Create a feature branch off of develop Work on that branch and push it to the remote repo Merge the feature branch into develop Clean up your branches This process works great for small features, but in my experience, it has one main drawback: it makes keeping a clean commit history more difficult. Ideally, before merging any branch, you should clean up your commit history by following the steps in my interactive rebasing post . However, because rebasing involves rewriting history, it's best not to rebase commits on branches that have already been pushed to a remote repository. This presents a slight problem when using GitFlow. If you're working on a feature branch that takes several days or even weeks to complete, you'll naturally want to push your changes to a remote periodically to ensure you don't lose any work if your laptop crashes. However, if you do this, then rebasing is trickier since you would be rewriting published history. The best solution I've found is to do all of your feature work on an intermediate individual branch first, and then merge that branch into your feature branch. The basic workflow then becomes slightly more involved: Create a feature branch off of develop Create an individual branch off of the feature branch Work on the individual branch, pushing to the remote often to avoid losing history When work on the feature is complete, merge the individual branch into the feature branch Then merge the feature branch into develop Clean up your branches In the next sections, I'm going to go over each of these steps, and show the commands necessary to execute them.","title":"Working on a new feature: step by step guide"},{"location":"2019/gitflow_2/#step-1-create-a-feature-branch","text":"Let's say you're a developer working on the feature ABC-101_cool_new_feature . Create a feature branch from develop and then push the branch: 1 2 3 4 5 6 git checkout develop # Make sure you have the latest changes to develop git pull git checkout -b feature/ABC-101_cool_new_feature # Set -u (upstream) so that git remembers what remote to push to on this branch git push -u origin head","title":"Step 1: Create a feature branch"},{"location":"2019/gitflow_2/#step-2-create-an-individual-branch-off-of-the-feature-branch","text":"To make your intermediate branch, fork a branch off of the feature branch you just created. For the individual branches, I like to use the naming convention: 1 <your-name>/<feature-branch-name-after-slash> So, if Alice is working on the feature/ABC-101_cool_new_feature branch, then she would make an individual branch named alice/ABC-101_cool_new_feature : 1 2 3 4 # Make sure you're on the feature/ABC-101_cool_new_feature branch git checkout feature/ABC-101_cool_new_feature branch git checkout -b alice/ABC-101_cool_new_feature git push -u origin head","title":"Step 2: Create an individual branch off of the feature branch"},{"location":"2019/gitflow_2/#step-3-work-on-the-individual-branch-and-push-to-remote-often","text":"Now that Alice has her individual branch set up, she can work on it and push to the remote as often as she likes. I usually make several commits per day and push to the remote once at the end of each day. But you can feel free to push as often as you like: you never know when your laptop will crash and you'll lose important work! 1 2 3 4 5 6 7 8 # Do work on the feature and continuously commit changes on the individual # branch and push to the remote git add -A git commit -m 'My commit message 1' # Do some more work git add -A git commit -m 'My commit message 2' git push","title":"Step 3: Work on the individual branch and push to remote often"},{"location":"2019/gitflow_2/#step-4-merge-the-individual-branch-back-into-the-feature-branch","text":"Once all work is done on the feature, commit your changes and push to the remote copy of your individual branch one last time. The next step is to merge your individual branch into the feature branch. Before merging, though, you'll want to make sure you have a clean commit history. Your individual branch likely has tens of commits at this point, many of which have unhelpful commit messages such as \"Fixed a typo\" or \"Made a small update.\" Rather than keep all of these as separate commits, you should squash these into one or a few more meaningful commits before merging. To do this, you can follow the instructions in my blog post on interactive rebasing. Once you have cleaned your commit history, then merge the individual branch into the feature branch. You'll also want to merge in develop to the feature branch as well, to make sure there are no merge conflicts between your feature code and what's already pushed in develop . 1 2 3 4 5 git checkout feature/ABC-101_cool_new_feature git pull git merge alice/ABC-101_cool_new_feature git merge develop git push Note You may need to resolve some merge conflicts at this stage. To do this, you can use a merge tool such as DiffMerge . You can also use Tim Pope's fugitive plugin to handle merge conflicts. For more info on how to do that, see this screencast .","title":"Step 4: Merge the individual branch back into the feature branch"},{"location":"2019/gitflow_2/#step-5-pr-from-feature-branch-into-develop","text":"Step five is to merge the feature branch into develop . To merge the feature branch, you can use a pull request (PR). A PR is a way to submit code changes for review and request that they be merged into a branch. Once the PR is approved, merge it and then delete the feature branch on the remote.","title":"Step 5: PR from feature branch into develop"},{"location":"2019/gitflow_2/#step-6-clean-up-local-branches","text":"Once the PR is merged, then work on the feature is almost complete. The last step is to clean up your local branch list by deleting the old branches. Note You can use git fetch -p to prune your remote branch list to remove any remote branches you're tracking that no longer exist. 1 2 3 4 5 6 git checkout develop git pull git branch -d alice/ABC-101_cool_new_feature git branch -d feature/ABC-101_cool_new_feature # Prune the inactive remote branches git fetch -p The feature is now complete.","title":"Step 6: Clean up local branches"},{"location":"2019/gitflow_2/#conclusion","text":"The above shouldn't be taken as the definitive guide or the only way to do GitFlow. This is just a method of working on features that has worked well for me in the past. Depending on the circumstance, you might find yourself wanting to adjust this workflow. For example, if you have a very small feature which will only take a day or two, you can of course skip creating an individual branch to work on and just work directly on the feature branch. Like anything related to workflow, you should design a workflow that fits your needs, not shoehorn your needs into a particular workflow.","title":"Conclusion"},{"location":"2019/rebasing/","text":"Using interactive rebase to ensure a clean git history \u00b6 The problem \u00b6 Sometimes, when working on a feature branch, your commit history can get messy. If your log looks like this: 1 2 3 4 926bdc9 - 8 minutes ago : OK, now it's fixed b8ae898 - 10 minutes ago : Now it's really fixed 564f4db - 15 minutes ago : Fixed a small mistake 0fac50d - 20 minutes ago : Added a new feature you should consider revising your commit history before pushing to a remote repo. To do this, you can do an interactive rebase . Rebasing \u00b6 Rebasing is a git tool for rewriting your commit history. Using rebase , you can squash multiple commits together into one, resulting in a cleaner commit history that looks like this: 1 926bdc9 - 8 minutes ago : Added a new feature To do this, run: 1 git rebase -i HEAD~4 The -i flag runs the rebase interactively, and HEAD~4 means that the rebase will allow you to edit the last 4 commits. This command will open up an interactive rebase vim window with the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 pick 926 bdc9 OK , now it 's fixed pick b8ae898 Now it' s really fixed pick 564 f4db Fixed a small mistake pick 0 fac50d Added a new feature # Rebase ad5b2e0 .. 6695 e26 onto 559 b098 ( 5 commands ) # # Commands : # p , pick < commit > = use commit # r , reword < commit > = use commit , but edit the commit message # e , edit < commit > = use commit , but stop for amending # s , squash < commit > = use commit , but meld into previous commit # f , fixup < commit > = like \"squash\" , but discard this commit 's log message # x, exec <command> = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with ' git rebase --continue') # d , drop < commit > = remove commit # l , label < label > = label current HEAD with a name # t , reset < label > = reset HEAD to a label # m , merge [ - C < commit > | - c < commit > ] < label > [ # < oneline > ] # . create a merge commit using the original merge commit ' s # . message ( or the oneline , if no original merge commit was # . specified ). Use - c < commit > to reword the commit message . # # These lines can be re - ordered ; they are executed from top to bottom . # # If you remove a line here THAT COMMIT WILL BE LOST . # # However , if you remove everything , the rebase will be aborted . # # Note that empty commits are commented out To squash all four of these commits into one, pick the top commit, and squash the lower three: 1 2 3 4 pick 926bdc9 OK, now it's fixed squash b8ae898 Now it's really fixed squash 564f4db Fixed a small mistake squash 0fac50d Added a new feature Then exit the rebase window with :wq . This will open a new vim window where you can view and edit the commit messages of the commits you are rebasing: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # This is a combination of 5 commits . # This is the 1 st commit message : Added a new feature # This is the commit message # 2 : Fixed a small mistake # This is the commit message # 3 : Now it 's really fixed # This is the commit message #4: OK, now it' s fixed # Please enter the commit message for your changes . Lines starting # with '#' will be ignored , and an empty message aborts the commit . # # Date : Sun Nov 24 22 : 05 : 15 2019 - 0600 # # interactive rebase in progress ; onto ad5b2e0 # Last commands done ( 5 commands done ): # squash 559 b098 4 # squash 6695 e26 5 # No commands remaining . # You are currently rebasing branch 'feature/DAT-2701_cool_new_feature' on 'ad5b2e0' . # # Changes to be committed : # new file : a . txt # new file : b . txt # new file : c . txt # new file : d . txt You can delete everything above the #Please enter line and rewrite a new commit message, and then :wq the file. Now your commit history is clean and you can push to the remote with a neatly organized commit log.","title":"Using interactive rebase to ensure a clean git history"},{"location":"2019/rebasing/#using-interactive-rebase-to-ensure-a-clean-git-history","text":"","title":"Using interactive rebase to ensure a clean git history"},{"location":"2019/rebasing/#the-problem","text":"Sometimes, when working on a feature branch, your commit history can get messy. If your log looks like this: 1 2 3 4 926bdc9 - 8 minutes ago : OK, now it's fixed b8ae898 - 10 minutes ago : Now it's really fixed 564f4db - 15 minutes ago : Fixed a small mistake 0fac50d - 20 minutes ago : Added a new feature you should consider revising your commit history before pushing to a remote repo. To do this, you can do an interactive rebase .","title":"The problem"},{"location":"2019/rebasing/#rebasing","text":"Rebasing is a git tool for rewriting your commit history. Using rebase , you can squash multiple commits together into one, resulting in a cleaner commit history that looks like this: 1 926bdc9 - 8 minutes ago : Added a new feature To do this, run: 1 git rebase -i HEAD~4 The -i flag runs the rebase interactively, and HEAD~4 means that the rebase will allow you to edit the last 4 commits. This command will open up an interactive rebase vim window with the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 pick 926 bdc9 OK , now it 's fixed pick b8ae898 Now it' s really fixed pick 564 f4db Fixed a small mistake pick 0 fac50d Added a new feature # Rebase ad5b2e0 .. 6695 e26 onto 559 b098 ( 5 commands ) # # Commands : # p , pick < commit > = use commit # r , reword < commit > = use commit , but edit the commit message # e , edit < commit > = use commit , but stop for amending # s , squash < commit > = use commit , but meld into previous commit # f , fixup < commit > = like \"squash\" , but discard this commit 's log message # x, exec <command> = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with ' git rebase --continue') # d , drop < commit > = remove commit # l , label < label > = label current HEAD with a name # t , reset < label > = reset HEAD to a label # m , merge [ - C < commit > | - c < commit > ] < label > [ # < oneline > ] # . create a merge commit using the original merge commit ' s # . message ( or the oneline , if no original merge commit was # . specified ). Use - c < commit > to reword the commit message . # # These lines can be re - ordered ; they are executed from top to bottom . # # If you remove a line here THAT COMMIT WILL BE LOST . # # However , if you remove everything , the rebase will be aborted . # # Note that empty commits are commented out To squash all four of these commits into one, pick the top commit, and squash the lower three: 1 2 3 4 pick 926bdc9 OK, now it's fixed squash b8ae898 Now it's really fixed squash 564f4db Fixed a small mistake squash 0fac50d Added a new feature Then exit the rebase window with :wq . This will open a new vim window where you can view and edit the commit messages of the commits you are rebasing: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # This is a combination of 5 commits . # This is the 1 st commit message : Added a new feature # This is the commit message # 2 : Fixed a small mistake # This is the commit message # 3 : Now it 's really fixed # This is the commit message #4: OK, now it' s fixed # Please enter the commit message for your changes . Lines starting # with '#' will be ignored , and an empty message aborts the commit . # # Date : Sun Nov 24 22 : 05 : 15 2019 - 0600 # # interactive rebase in progress ; onto ad5b2e0 # Last commands done ( 5 commands done ): # squash 559 b098 4 # squash 6695 e26 5 # No commands remaining . # You are currently rebasing branch 'feature/DAT-2701_cool_new_feature' on 'ad5b2e0' . # # Changes to be committed : # new file : a . txt # new file : b . txt # new file : c . txt # new file : d . txt You can delete everything above the #Please enter line and rewrite a new commit message, and then :wq the file. Now your commit history is clean and you can push to the remote with a neatly organized commit log.","title":"Rebasing"},{"location":"2020/aws/","text":"blog post ideas: - git fetch -p - git aliases - aws - net worth predicter AWS Post \u00b6 The official boto3 documentation doesn't explicitly say that all of its calls to the Athena API are asynchronous. But a good clue to this is the fact that there is no method named run_query . Instead, there's start_query_execution . At first, when I saw this, I thought, \"Hey, they just chose a weird name for the method you use to run a query in Athena.\" After all, the documentation for this method just says: 1 2 Runs the SQL query statements contained in the Query. Requires you to have access to the workgroup in which the query ran. About a week of debugging later, though, I realized that it was named that way because that's exactly what this method does: start a query execution. If you need to run several queries in succession, and each successive query depends on the last[^1], then you need to figure out some way to have each next query wait until the previous one finishes before it starts. Otherwise, your code turns into a giant race condition . [^1] For example, if you're running multiple DDL scripts... The way around this is...","title":"Aws"},{"location":"2020/aws/#aws-post","text":"The official boto3 documentation doesn't explicitly say that all of its calls to the Athena API are asynchronous. But a good clue to this is the fact that there is no method named run_query . Instead, there's start_query_execution . At first, when I saw this, I thought, \"Hey, they just chose a weird name for the method you use to run a query in Athena.\" After all, the documentation for this method just says: 1 2 Runs the SQL query statements contained in the Query. Requires you to have access to the workgroup in which the query ran. About a week of debugging later, though, I realized that it was named that way because that's exactly what this method does: start a query execution. If you need to run several queries in succession, and each successive query depends on the last[^1], then you need to figure out some way to have each next query wait until the previous one finishes before it starts. Otherwise, your code turns into a giant race condition . [^1] For example, if you're running multiple DDL scripts... The way around this is...","title":"AWS Post"}]}